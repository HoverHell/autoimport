{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Autoimport missing python libraries. Throughout the development of a python program you continuously need to manage the python import statements either because you need one new object or because you no longer need it. This means that you need to stop writing whatever you were writing, go to the top of the file, create or remove the import statement and then resume coding. This workflow break is annoying and almost always unnecessary. autoimport solves this problem if you execute it whenever you have an import error, for example by configuring your editor to run it when saving the file. Installing \u00b6 pip install autoimport Usage \u00b6 Imagine we've got the following source code: import requests def hello ( names : Tuple [ str ]) -> None : for name in names : print ( f \"Hi { name } !\" ) os . getcwd () It has the following import errors: requests is imported but unused. os and Tuple are needed but not imported. After running autoimport the resulting source code will be: import os from typing import Tuple def hello ( names : Tuple [ str ]) -> None : for name in names : print ( f \"Hi { name } !\" ) os . getcwd () autoimport can be used both as command line tool and as a library. As a command line tool: $: autoimport file.py As a library: from autoimport import fix_files fix_files ([ 'file.py' ]) autoimport will add all dependencies at the top of the file, we suggest using isort and black afterwards to clean the file. Moving the imports to the top \u00b6 There are going to be import cases that may not work, if you find one, please open an issue . While we fix it you can write the import statement wherever you are in the file and the next time you run autoimport it will get moved to the top. If you don't want a specific line to go to the top, add the # noqa: autoimport at the end. For example: a = 1 from os import getcwd # noqa: autoimport getcwd () References \u00b6 As most open sourced programs, autoimport is standing on the shoulders of giants, namely: autoflake Inspiration of autoimport . Also used their code to interact with pyflakes . Click Used to create the command line interface. Contributing \u00b6 For guidance on setting up a development environment and how to make a contribution to autoimport , see Contributing to autoimport .","title":"Overview"},{"location":"#installing","text":"pip install autoimport","title":"Installing"},{"location":"#usage","text":"Imagine we've got the following source code: import requests def hello ( names : Tuple [ str ]) -> None : for name in names : print ( f \"Hi { name } !\" ) os . getcwd () It has the following import errors: requests is imported but unused. os and Tuple are needed but not imported. After running autoimport the resulting source code will be: import os from typing import Tuple def hello ( names : Tuple [ str ]) -> None : for name in names : print ( f \"Hi { name } !\" ) os . getcwd () autoimport can be used both as command line tool and as a library. As a command line tool: $: autoimport file.py As a library: from autoimport import fix_files fix_files ([ 'file.py' ]) autoimport will add all dependencies at the top of the file, we suggest using isort and black afterwards to clean the file.","title":"Usage"},{"location":"#moving-the-imports-to-the-top","text":"There are going to be import cases that may not work, if you find one, please open an issue . While we fix it you can write the import statement wherever you are in the file and the next time you run autoimport it will get moved to the top. If you don't want a specific line to go to the top, add the # noqa: autoimport at the end. For example: a = 1 from os import getcwd # noqa: autoimport getcwd ()","title":"Moving the imports to the top"},{"location":"#references","text":"As most open sourced programs, autoimport is standing on the shoulders of giants, namely: autoflake Inspiration of autoimport . Also used their code to interact with pyflakes . Click Used to create the command line interface.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment and how to make a contribution to autoimport , see Contributing to autoimport .","title":"Contributing"},{"location":"contributing/","text":"We'd love you to contribute to autoimport ! Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. However, to report a security vulnerability, please see our security policy . To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import autoimport.version; print(autoimport.version.version_info())\" Please try to always include the above unless you're unable to install autoimport or know it's not relevant to your question or feature request. Pull Requests \u00b6 It should be extremely simple to get started and create a Pull Request. autoimport is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. To make contributing as easy and fast as possible, you'll want to run tests and linting locally. You'll need to have python 3.6 , 3.7 , or 3.8 , virtualenv , git , and make installed. # 1. clone your fork and cd into the repo directory git clone git@github.com:<your username>/autoimport.git cd autoimport # 2. Set up a virtualenv for running tests virtualenv -p ` which python3.7 ` env source env/bin/activate # (or however you prefer to setup a python environment, 3.6 will work too) # 3. Install autoimport , dependencies and configure the pre-commits make install # 4. Checkout a new branch and make your changes git checkout -b my-new-feature-branch # make your changes... # 5. Fix formatting and imports make format # autoimport uses black to enforce formatting and isort to fix imports # (https://github.com/ambv/black, https://github.com/timothycrosley/isort) # 6. Run tests and linting make # there are a few sub-commands in Makefile like `test-code` or `test-examples` # which you might want to use, but generally just `make` should be all you need # 7. Build documentation make docs # if you have changed the documentation make sure it builds successfully # once built it will serve the documentation at localhost:8000 # ... commit, push, and create your pull request tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs.","title":"Contributing"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. However, to report a security vulnerability, please see our security policy . To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import autoimport.version; print(autoimport.version.version_info())\" Please try to always include the above unless you're unable to install autoimport or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"It should be extremely simple to get started and create a Pull Request. autoimport is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. To make contributing as easy and fast as possible, you'll want to run tests and linting locally. You'll need to have python 3.6 , 3.7 , or 3.8 , virtualenv , git , and make installed. # 1. clone your fork and cd into the repo directory git clone git@github.com:<your username>/autoimport.git cd autoimport # 2. Set up a virtualenv for running tests virtualenv -p ` which python3.7 ` env source env/bin/activate # (or however you prefer to setup a python environment, 3.6 will work too) # 3. Install autoimport , dependencies and configure the pre-commits make install # 4. Checkout a new branch and make your changes git checkout -b my-new-feature-branch # make your changes... # 5. Fix formatting and imports make format # autoimport uses black to enforce formatting and isort to fix imports # (https://github.com/ambv/black, https://github.com/timothycrosley/isort) # 6. Run tests and linting make # there are a few sub-commands in Makefile like `test-code` or `test-examples` # which you might want to use, but generally just `make` should be all you need # 7. Build documentation make docs # if you have changed the documentation make sure it builds successfully # once built it will serve the documentation at localhost:8000 # ... commit, push, and create your pull request tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs.","title":"Pull Requests"},{"location":"editor_integration/","text":"For a smother experience, you can run autoimport each time you save your file in your editor. Vim \u00b6 To integrate autoimport into Vim, I recommend using the ale plugin . If you are new to ALE, check this post . ale is configured to run autoimport automatically by default.","title":"Editor integration"},{"location":"editor_integration/#vim","text":"To integrate autoimport into Vim, I recommend using the ale plugin . If you are new to ALE, check this post . ale is configured to run autoimport automatically by default.","title":"Vim"},{"location":"reference/","text":"autoimport.__init__ special \u00b6 Python program to automatically import missing python libraries. Functions fix_code: Fix python source code to correct missed or unused import statements. fix_files: Fix the python source code of a list of files. autoimport.services \u00b6 Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose. fix_code ( source_code , aliases = None ) \u00b6 Fix python source code to correct import statements. It corrects these errors: * Add missed import statements. * Remove unused import statements. * Move import statements to the top. Parameters: Name Type Description Default source_code str Source code to be corrected. required aliases Optional[Dict[str, str]] User defined import lines accessed by object name. None Returns: Type Description str Corrected source code. Source code in autoimport/services.py def fix_code ( source_code : str , aliases : Optional [ Dict [ str , str ]] = None ) -> str : \"\"\"Fix python source code to correct import statements. It corrects these errors: * Add missed import statements. * Remove unused import statements. * Move import statements to the top. Args: source_code: Source code to be corrected. aliases: User defined import lines accessed by object name. Returns: Corrected source code. \"\"\" source_code = _fix_flake_import_errors ( source_code , aliases ) source_code = _move_imports_to_top ( source_code ) return source_code fix_files ( files ) \u00b6 Fix the python source code of a list of files. If the input is taken from stdin, it will output the value to stdout. Parameters: Name Type Description Default files Tuple[_io.TextIOWrapper] List of files to fix. required Returns: Type Description Optional[str] Fixed code retrieved from stdin or None. Source code in autoimport/services.py def fix_files ( files : Tuple [ TextIOWrapper ]) -> Optional [ str ]: \"\"\"Fix the python source code of a list of files. If the input is taken from stdin, it will output the value to stdout. Args: files: List of files to fix. Returns: Fixed code retrieved from stdin or None. \"\"\" for file_wrapper in files : source = file_wrapper . read () fixed_source = fix_code ( source ) try : # Click testing runner doesn't simulate correctly the reading from stdin # instead of setting the name attribute to `<stdin>` it gives an # AttributeError. But when you use it outside testing, no AttributeError # is raised and name has the value <stdin>. So there is no way of testing # this behaviour. if file_wrapper . name == \"<stdin>\" : # pragma no cover output = \"output\" else : output = \"file\" except AttributeError : output = \"output\" if output == \"file\" : file_wrapper . seek ( 0 ) file_wrapper . write ( fixed_source ) file_wrapper . truncate () else : return fixed_source return None autoimport.entrypoints special \u00b6 Define the different ways to expose the program functionality. load_logger ( verbose = False ) \u00b6 Configure the Logging logger. Parameters: Name Type Description Default verbose bool Set the logging level to Debug. False Source code in autoimport/entrypoints/__init__.py def load_logger ( verbose : bool = False ) -> None : # pragma no cover \"\"\"Configure the Logging logger. Args: verbose: Set the logging level to Debug. \"\"\" logging . addLevelName ( logging . INFO , \"[ \\033 [36m+ \\033 [0m]\" ) logging . addLevelName ( logging . ERROR , \"[ \\033 [31m+ \\033 [0m]\" ) logging . addLevelName ( logging . DEBUG , \"[ \\033 [32m+ \\033 [0m]\" ) logging . addLevelName ( logging . WARNING , \"[ \\033 [33m+ \\033 [0m]\" ) if verbose : logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG , format = \" %(levelname)s %(message)s \" ) else : logging . basicConfig ( stream = sys . stderr , level = logging . INFO , format = \" %(levelname)s %(message)s \" ) cli \u00b6 Command line interface definition. autoimport.version \u00b6 Utilities to retrieve the information of the program version. version_info () \u00b6 Display the version of the program, python and the platform. Source code in autoimport/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"repository-pattern version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"Reference"},{"location":"reference/#autoimport.__init__","text":"Python program to automatically import missing python libraries. Functions fix_code: Fix python source code to correct missed or unused import statements. fix_files: Fix the python source code of a list of files.","title":"__init__"},{"location":"reference/#autoimport.services","text":"Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.","title":"services"},{"location":"reference/#autoimport.services.fix_code","text":"Fix python source code to correct import statements. It corrects these errors: * Add missed import statements. * Remove unused import statements. * Move import statements to the top. Parameters: Name Type Description Default source_code str Source code to be corrected. required aliases Optional[Dict[str, str]] User defined import lines accessed by object name. None Returns: Type Description str Corrected source code. Source code in autoimport/services.py def fix_code ( source_code : str , aliases : Optional [ Dict [ str , str ]] = None ) -> str : \"\"\"Fix python source code to correct import statements. It corrects these errors: * Add missed import statements. * Remove unused import statements. * Move import statements to the top. Args: source_code: Source code to be corrected. aliases: User defined import lines accessed by object name. Returns: Corrected source code. \"\"\" source_code = _fix_flake_import_errors ( source_code , aliases ) source_code = _move_imports_to_top ( source_code ) return source_code","title":"fix_code()"},{"location":"reference/#autoimport.services.fix_files","text":"Fix the python source code of a list of files. If the input is taken from stdin, it will output the value to stdout. Parameters: Name Type Description Default files Tuple[_io.TextIOWrapper] List of files to fix. required Returns: Type Description Optional[str] Fixed code retrieved from stdin or None. Source code in autoimport/services.py def fix_files ( files : Tuple [ TextIOWrapper ]) -> Optional [ str ]: \"\"\"Fix the python source code of a list of files. If the input is taken from stdin, it will output the value to stdout. Args: files: List of files to fix. Returns: Fixed code retrieved from stdin or None. \"\"\" for file_wrapper in files : source = file_wrapper . read () fixed_source = fix_code ( source ) try : # Click testing runner doesn't simulate correctly the reading from stdin # instead of setting the name attribute to `<stdin>` it gives an # AttributeError. But when you use it outside testing, no AttributeError # is raised and name has the value <stdin>. So there is no way of testing # this behaviour. if file_wrapper . name == \"<stdin>\" : # pragma no cover output = \"output\" else : output = \"file\" except AttributeError : output = \"output\" if output == \"file\" : file_wrapper . seek ( 0 ) file_wrapper . write ( fixed_source ) file_wrapper . truncate () else : return fixed_source return None","title":"fix_files()"},{"location":"reference/#autoimport.entrypoints","text":"Define the different ways to expose the program functionality.","title":"entrypoints"},{"location":"reference/#autoimport.entrypoints.load_logger","text":"Configure the Logging logger. Parameters: Name Type Description Default verbose bool Set the logging level to Debug. False Source code in autoimport/entrypoints/__init__.py def load_logger ( verbose : bool = False ) -> None : # pragma no cover \"\"\"Configure the Logging logger. Args: verbose: Set the logging level to Debug. \"\"\" logging . addLevelName ( logging . INFO , \"[ \\033 [36m+ \\033 [0m]\" ) logging . addLevelName ( logging . ERROR , \"[ \\033 [31m+ \\033 [0m]\" ) logging . addLevelName ( logging . DEBUG , \"[ \\033 [32m+ \\033 [0m]\" ) logging . addLevelName ( logging . WARNING , \"[ \\033 [33m+ \\033 [0m]\" ) if verbose : logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG , format = \" %(levelname)s %(message)s \" ) else : logging . basicConfig ( stream = sys . stderr , level = logging . INFO , format = \" %(levelname)s %(message)s \" )","title":"load_logger()"},{"location":"reference/#autoimport.entrypoints.cli","text":"Command line interface definition.","title":"cli"},{"location":"reference/#autoimport.version","text":"Utilities to retrieve the information of the program version.","title":"version"},{"location":"reference/#autoimport.version.version_info","text":"Display the version of the program, python and the platform. Source code in autoimport/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"repository-pattern version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"version_info()"}]}